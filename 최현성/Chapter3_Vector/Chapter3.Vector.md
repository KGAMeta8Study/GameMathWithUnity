# 3.벡터

# **벡터**

- 벡터(vector)는 크기와 방향을 갖는 수학적 개념으로, 물체의 위치, 변위, 방향, 속도 등 다양한 물리적 속성을 표현할 수 있다. Unity에서는 벡터를 사용하여 게임 객체의 **위치**, **이동**, **회전**, **물리 계산**을 수행한다. 여기에서는 위치벡터, 수벡터, 성분, 행벡터, 열벡터, 변위와 관련된 개념을 Unity의 맥락에서 정리한다.

---

## **1. 위치벡터 (Position Vector)**

**위치벡터**는 **원점을 기준으로 한 특정 위치를 나타내는 벡터**이다.

- Unity에서 위치벡터는 보통 게임 객체의 좌표로 표현되며, **월드 좌표계**나 **로컬 좌표계**를 기준으로 객체의 위치를 나타낸다.
- 표현 
$p=(x,y,z)$
여기서 x, y, z는 객체의 위치 성분이다.

### Unity에서의 예

- 객체의 위치 가져오기:
    
    ```csharp
    Vector3 position = transform.position; // 월드 좌표에서의 위치벡터
    ```
    
- 객체의 위치 설정:
    
    ```csharp
    transform.position = new Vector3(1, 2, 3);
    ```
    

---

## **2. 수벡터 (Scalar Vector)**

**수벡터**는 벡터를 특정 값(스칼라, Scalar)로 곱한 결과를 의미하며, **벡터의 크기를 조정**한다.

- Unity에서 수벡터는 게임 객체의 크기, 이동 거리, 속도를 조절하는 데 사용된다.
- 예: 벡터의 스칼라 배수 계산
$v′=k⋅v=k⋅(x,y,z)=(k⋅x,k⋅y,k⋅z)$

### Unity에서의 예

- 벡터의 크기를 두 배로 만들기
    
    ```csharp
    Vector3 scaledVector = 2 * transform.forward; // forward 방향으로 두 배 멀리 이동
    ```
    

---

## **3. 성분 (Components)**

벡터는 **성분**으로 이루어져 있으며, 각 성분은 좌표축(예: x, y, z)에 대응하는 값이다.

- Unity의 `Vector3` 구조체에서 벡터의 성분은 x, y, z로 접근 가능하다.
- 성분은 벡터의 방향과 크기를 결정하는 기본 요소이다.

### Unity에서의 예

- 벡터의 성분 접근:
    
    ```csharp
    Vector3 velocity = new Vector3(5, 3, 0);
    float xComponent = velocity.x; // x 성분
    float yComponent = velocity.y; // y 성분
    ```
    

---

## **4. 행벡터 (Row Vector)와 열벡터 (Column Vector)**

벡터는 **행벡터** 또는 **열벡터**로 표현될 수 있다:

- **행벡터**: $v=[x,y,z]$
- **열벡터**: $v=xyz$

### Unity에서의 사용

Unity는 기본적으로 **열벡터 방식**을 사용한다.

행렬 변환과 벡터 연산에서 열벡터를 사용하여 월드 좌표 변환과 같은 작업을 수행한다.

### Unity에서의 예

- 변환 행렬과 열벡터를 곱하여 위치를 변환:
    
    ```csharp
    Vector3 transformedPosition = transform.localToWorldMatrix.MultiplyPoint3x4(localPosition);
    ```
    

---

## **5. 변위 (Displacement)**

**변위**는 한 점에서 다른 점으로 이동했을 때의 방향과 거리를 나타내는 벡터이다.

- 변위는 두 위치벡터의 차로 계산: $d=p2−p1$
- 변위는 크기(거리)와 방향을 포함하므로 이동이나 충돌 계산에 유용하다.

### Unity에서의 예

- 두 객체 간 변위 계산:
    
    ```csharp
    Vector3 displacement = target.position - transform.position
    ```
    
- 변위 벡터의 크기(거리):
    
    ```csharp
    float distance = displacement.magnitude
    ```
    

---

## **Unity에서의 벡터 활용 예**

1. **위치 벡터로 이동**:
    
    ```csharp
    transform.position += new Vector3(1, 0, 0); // x축 방향으로 1만큼 이동
    ```
    
2. **수벡터로 속도 조정**:
    
    ```csharp
    Vector3 velocity = new Vector3(0, 5, 0);
    Vector3 scaledVelocity = 2 * velocity; // 속도를 두 배로 증가
    ```
    
3. **변위 계산으로 방향 설정**:
    
    ```csharp
    Vector3 displacement = target.position - transform.position;
    transform.forward = displacement.normalized; // 변위 방향으로 객체 회전
    ```
    

# **기하벡터**

- 기하벡터(Geometric Vector)는 **공간에서 크기와 방향**을 동시에 나타내는 기본적인 벡터로, 점과 점 사이의 상대적 위치, 방향, 길이(거리)를 표현한다. 기하벡터는 물리적 이동, 회전, 충돌, 힘의 방향 등을 표현하는 데 중요한 역할을 하며, Unity와 같은 3D 환경에서는 객체의 위치와 관계를 설명하는 기본 도구이다.

---

## **1. 기하벡터의 정의**

기하벡터는 보통  $v=(x,y,z)$ 형태로 표현되며, 다음과 같은 정보를 포함한다:

- **크기 (Magnitude)**: 벡터의 길이, 즉 시작점에서 끝점까지의 거리.
$∣v∣=x2+y2+z2$
- **방향 (Direction)**: 벡터가 가리키는 공간상의 방향.

기하벡터는 **위치벡터**와 달리 특정한 시작점과 끝점을 가지며, 두 점 간의 상대적 위치를 표현하는 데 사용된다.

---

## **2. 기하벡터와 위치벡터의 차이**

- **위치벡터**: 원점(0, 0, 0)을 기준으로 한 특정 점의 위치를 나타냄.
- **기하벡터**: 두 점 간의 **상대적 방향과 거리**를 나타냄.

### 예제

- 점 A(1,2,3)와 B(4,5,6) 사이의 기하벡
    
    
    $vAB=B−A=(4−1,5−2,6−3)=(3,3,3)$
    
    이 벡터는 A에서 B로 가는 방향과 길이를 나타냄.
    

---

## **3. Unity에서 기하벡터의 활용**

### **1) 객체 간의 방향**

두 점 간의 방향을 구하려면 기하벡터를 사용한다. Unity에서는 다음과 같이 계산한다:

```csharp
	Vector3 direction = target.position - transform.position; // 방향 벡터
```

- **단위벡터 (Normalized Vector)**: 방향만을 나타내기 위해 크기를 1로 정규화.
    
    ```csharp
    Vector3 normalizedDirection = direction.normalized;
    ```
    

### **2) 두 점 간의 거리**

기하벡터의 크기를 계산하여 두 점 간의 거리를 구할 수 있다:

```csharp
float distance = direction.magnitude; // 벡터의 크기
```

### **3) 이동 계산**

기하벡터를 사용하여 객체를 특정 방향으로 이동:

```csharp
transform.position += direction.normalized * speed * Time.deltaTime; // 방향으로 이동
```

## **스칼라**

**스칼라**는 크기(또는 양)만을 가진 값으로, 방향성이 없는 수학적 요소다.

- 벡터가 (x,y,z)와 같은 형태로 크기와 방향을 가지는 반면, 스칼라는 단일 값으로만 존재한다.
- 예를 들어, 물체의 **속도**나 **질량**은 스칼라 양이며, **벡터**로 나타낼 수 없다.

### **스칼라의 예시**

- **속도**: 속도는 벡터로 나타낼 수 있지만, 그 크기만을 나타내는 **속도**는 스칼라로 표현된다. 예: "속도가 5m/s"에서 5m/s는 스칼라이다.
- **온도**: 온도는 방향이 없는 크기만을 나타내는 물리적 양이므로 스칼라에 속한다.
- **시간**: 시간도 스칼라이며, 방향 없이 경과하는 양만을 측정한다.

# **벡터 연산에서 덧셈, 뺄셈, 교환법칙, 결합법칙**

벡터 연산에서 **덧셈**, **뺄셈**, **교환법칙**, **결합법칙**은 벡터를 다룰 때 중요한 개념들로, Unity와 같은 게임 엔진에서 물체의 이동, 회전, 물리적 상호작용 등을 계산할 때 자주 사용된다.

---

## **1. 벡터 덧셈 (Vector Addition)**

두 벡터 $a=(ax,ay,az)$와 $b=(bx,by,bz)$의 덧셈은 각 성분별로 더하는 방식으로 이루어진다. 즉, 각 벡터의 **같은 차원의 성분들**을 더하는 것이다.

### **벡터 덧셈 공식**

$c=a+b=(ax+bx,ay+by,az+bz)$

따라서 두 벡터의 합은 각 성분을 더한 새로운 벡터가 된다.

### **Unity에서의 예**

```csharp
Vector3 a = new Vector3(1, 2, 3);
Vector3 b = new Vector3(4, 5, 6);
Vector3 sum = a + b; // 결과: (5, 7, 9)
```

---

## **2. 벡터 뺄셈 (Vector Subtraction)**

벡터의 뺄셈은 각 성분별로 뺄셈을 진행하여 새로운 벡터를 얻는 연산이다. 즉, **두 벡터의 각 성분을 빼는** 방식이다.

### **벡터 뺄셈 공식**

$d=a−b=(ax−bx,ay−by,az−bz)$

벡터 뺄셈은 한 벡터에서 다른 벡터를 뺄 때, 각 성분을 개별적으로 처리하는 연산이다.

### **Unity에서의 예**

```csharp
Vector3 a = new Vector3(5, 7, 9);
Vector3 b = new Vector3(1, 2, 3);
Vector3 difference = a - b; // 결과: (4, 5, 6)
```

---

## **3. 벡터 연산의 교환법칙 (Commutative Property)**

벡터 덧셈은 **교환법칙**을 따르며, 벡터의 덧셈 순서를 바꿔도 결과는 동일하다. 즉, 벡터 a와 벡터 b의 덧셈 순서를 바꿔도 결과 벡터는 동일하다.

### **교환법칙 공식**

$a+b=b+a$

벡터 덧셈은 **순서에 관계없이** 결과가 같다는 것을 의미한다.

### **Unity에서의 예**

```csharp
Vector3 a = new Vector3(1, 2, 3);
Vector3 b = new Vector3(4, 5, 6);
Vector3 sum1 = a + b; // 결과: (5, 7, 9)
Vector3 sum2 = b + a; // 결과: (5, 7, 9)
```

위와 같이, 덧셈 순서를 바꿔도 결과는 동일하다.

---

## **4. 벡터 연산의 결합법칙 (Associative Property)**

벡터 덧셈은 **결합법칙**을 따르며, 벡터 덧셈의 그룹화 순서를 바꿔도 결과는 동일하다. 즉, 벡터 a b, c에 대해 벡터의 덧셈을 할 때, 어떤 두 벡터를 먼저 더하든 상관없이 최종 결과는 동일하다.

### **결합법칙 공식**

$(a+b)+c=a+(b+c)$

즉, 덧셈 순서에 관계없이 결과가 변하지 않는다.

### **Unity에서의 예**

```csharp
Vector3 a = new Vector3(1, 2, 3);
Vector3 b = new Vector3(4, 5, 6);
Vector3 c = new Vector3(7, 8, 9);
Vector3 result1 = (a + b) + c; // 결과: (12, 15, 18)
Vector3 result2 = a + (b + c); // 결과: (12, 15, 18)
```

두 벡터 덧셈을 결합하는 방식에 상관없이 결과는 같다.

---

## **벡터 덧셈, 뺄셈, 교환법칙, 결합법칙의 Unity 활용 예**

Unity에서는 벡터 연산이 **물리적 계산**(예: 속도, 이동 경로)과 **게임 객체 간의 상호작용**에 많이 사용된다. 다음은 이를 Unity에서 어떻게 활용할 수 있는지에 대한 예시이다:

### **1. 물체의 이동**

게임에서 캐릭터나 물체가 이동할 때 벡터 덧셈을 사용하여 위치를 업데이트한다. 예를 들어, 물체가 **현재 위치**에서 **이동 벡터**만큼 이동할 때 덧셈을 활용한다.

```csharp
Vector3 position = new Vector3(0, 0, 0); // 물체의 현재 위치
Vector3 movement = new Vector3(5, 0, 0); // 물체가 이동할 벡터
position = position + movement; // 새로운 위치 계산
```

### **2. 물체 간의 거리 계산**

벡터 뺄셈을 사용하여 두 물체 사이의 **변위 벡터**를 계산하고, 그 크기를 사용해 두 물체 간의 **거리**를 계산할 수 있다.

```csharp

Vector3 positionA = new Vector3(1, 1, 1);
Vector3 positionB = new Vector3(4, 5, 6);
Vector3 displacement = positionB - positionA; // 두 물체 간의 변위 벡터
float distance = displacement.magnitude; // 변위 벡터의 크기 (거리)
```

# **벡터의 스칼라 곱셈 및 나눗셈**

벡터와 스칼라 간의 연산은 벡터의 크기나 방향을 조정하는 데 유용하며, Unity와 같은 게임 엔진에서 다양한 물리적, 기하학적 계산을 할 때 사용된다. 스칼라 곱셈과 나눗셈은 벡터의 크기(길이) 또는 방향을 변경하는 연산으로, 게임에서 이동, 회전, 물리적 상호작용을 처리할 때 자주 활용된다.

---

## **1. 스칼라 곱셈 (Scalar Multiplication)**

**스칼라 곱셈**은 벡터와 스칼라(실수) 사이의 연산으로, 벡터의 **크기**를 변경하지만 방향은 그대로 유지하거나 반대로 뒤집는 방식이다. 벡터에 스칼라 값을 곱하면 벡터의 각 성분이 그 스칼라 값만큼 곱해져 새로운 벡터를 생성한다.

### **스칼라 곱셈 공식**

$c=k⋅a=(k⋅ax,k⋅ay,k⋅az)$

여기서 k는 스칼라 값이며, a는 벡터이다. 스칼라 값이 **양수**이면 벡터의 방향은 그대로 유지하고 크기만 커지며, **음수**이면 벡터의 방향이 반대로 바뀌고 크기는 절댓값만큼 늘어난다.

### **Unity에서의 예**

```csharp
Vector3 a = new Vector3(1, 2, 3);
float scalar = 2f;
Vector3 result = scalar * a; // 결과: (2, 4, 6)
```

위의 예시에서, 벡터 a\mathbf{a}a에 스칼라 값 222를 곱하여 크기가 2배 커진 벡터를 생성했다.

---

## **2. 스칼라 나눗셈 (Scalar Division)**

**스칼라 나눗셈**은 벡터를 스칼라 값으로 나누는 연산으로, 벡터의 **크기를 줄이거나** 크기만큼 분배하는 효과를 낸다. 스칼라 값이 0이 아니어야 하며, 벡터의 각 성분을 스칼라 값으로 나누어 새로운 벡터를 만든다.

### **스칼라 나눗셈 공식**

$c=ka=(kax,kay,kaz)$

여기서 k는 스칼라 값이며, a는 벡터이다. 스칼라 값이 **양수**일 경우 벡터의 크기가 줄어들며, **음수**일 경우 벡터의 방향이 바뀌고 크기가 줄어든다.

### **Unity에서의 예**

```csharp
Vector3 a = new Vector3(2, 4, 6);
float scalar = 2f;
Vector3 result = a / scalar; // 결과: (1, 2, 3)
```

위의 예시에서, 벡터 a를 스칼라 값 2로 나누어 크기가 반으로 줄어든 벡터를 생성했다.

---

## **3. 스칼라 곱셈과 나눗셈의 용도**

### **스칼라 곱셈의 주요 용도**

- **속도 조정**: 물체가 일정한 속도로 이동하는 경우, 스칼라 곱셈을 사용하여 속도를 설정할 수 있다. 예를 들어, 물체의 이동 방향 벡터에 일정한 속도를 곱하면 물체의 이동 벡터가 그 속도에 맞게 크기가 조정된다.
- **방향 조정**: 벡터의 크기를 줄이거나 늘려서 물체의 이동 속도나 방향을 제어하는 데 사용된다.

### **Unity에서의 예**

```csharp
Vector3 direction = new Vector3(1, 0, 0); // x축 방향
float speed = 5f; // 속도
Vector3 movement = direction * speed * Time.deltaTime; // 물체의 이동 벡터
```

이 코드에서는 물체의 이동 방향 벡터에 속도 값을 곱하여, 매 프레임마다 물체를 이동시키는 방식으로 스칼라 곱셈을 활용하고 있다.

---

### **스칼라 나눗셈의 주요 용도**

- **정규화**: 벡터를 정규화(크기를 1로 만드는 것)할 때 스칼라 나눗셈을 사용한다. 벡터를 자신의 크기로 나누면 그 벡터의 방향만을 유지하고 크기는 1이 된다. 이는 벡터의 방향을 유지하면서, 물체의 이동이나 회전에서 **일관된 속도**를 유지할 때 유용하다.

### **Unity에서의 예**

```csharp
Vector3 a = new Vector3(3, 4, 0);
float magnitude = a.magnitude; // 벡터의 크기
Vector3 normalized = a / magnitude; // 정규화된 벡터
```

위 코드에서는 벡터 a를 자신의 크기로 나누어 **정규화된 벡터**를 구하고 있다.

---

## **4. 스칼라 곱셈과 나눗셈의 특성**

### **스칼라 곱셈의 특성**

- 스칼라 곱셈은 **분배 법칙**을 따른다. 즉, 벡터와 두 개의 스칼라 값의 곱은 두 스칼라 값의 곱을 각각 벡터에 적용한 결과와 같다.
$k⋅(a+b)=k⋅a+k⋅b$
- 또한, 스칼라 곱셈은 **결합 법칙**을 따른다. 즉, 두 스칼라 값이 있을 때 순서에 상관없이 곱셈을 진행할 수 있다.
$k⋅(m⋅a)=(k⋅m)⋅a$

### **스칼라 나눗셈의 특성**

- 나눗셈은 **분배 법칙**을 따르며, 벡터를 각각의 성분에 대해 나누는 연산이기 때문에 벡터의 크기 조정에 유용하다.
여기서 k1는 스칼라 값에 대한 역수이다.
    
    $\frac{\mathbf{a}}{k} = \mathbf{a} \cdot \frac{1}{k}$
    

## **좌표계 (Coordinate System)**

좌표계는 벡터를 **좌표**라는 수로 표현할 수 있도록 해주는 기준이 되는 시스템이다. 기본적으로 하나의 벡터를 숫자(좌표)로 표현하기 위한 **기준축**들이 정의된다. 좌표계에서 벡터의 위치는 기준점(원점)에서부터 다른 점까지의 **거리**와 **방향**으로 정의된다.

### **좌표계의 종류**

- **직교좌표계 (Cartesian Coordinate System)**: 가장 일반적으로 사용되는 좌표계로, 직각으로 교차하는 축들(x, y, z)이 정의되어 있다. 이 축을 기준으로 벡터를 표현한다.
- **극좌표계 (Polar Coordinate System)**: 2D 평면에서 원점을 기준으로 각도와 반지름을 사용하여 위치를 표현한다.
- **구면좌표계 (Spherical Coordinate System)**: 3D 공간에서 구형 좌표계를 사용해 위치를 표현한다. 각도와 반지름을 이용해 점을 정의한다.

---

## **2. 기저 (Basis)**

**기저**는 벡터 공간에서 벡터를 **유일하게 표현**하기 위한 **기준 벡터**들의 집합이다. 모든 벡터는 이 기저 벡터들의 선형 결합으로 표현될 수 있다. 기저는 벡터 공간의 **차원**을 정의하며, 그 차원 수는 **기저 벡터의 개수**와 같다.

기저는 벡터 공간 내에서 벡터를 표현할 때 **기준**이 되는 벡터들이며, 이 벡터들을 조합하여 공간 내의 모든 벡터를 **선형 결합**으로 나타낼 수 있다.

### **기저 벡터**

- 기저 벡터 (Basis Vectors)는 벡터 공간 내에서 다른 벡터들을 표현하는 데 필요한 **최소한의 벡터들**이다.
- 예를 들어, 3D 공간에서는 **세 개의 기저 벡터** $ex,ey,ez$가 필요하다. 이 벡터들은 각각 x, y, z 축을 따라 하나의 단위 크기를 갖는 벡터로 정의된다.

### **기저와 좌표계의 관계**

- 좌표계는 벡터를 **기준 벡터들**의 선형 결합으로 나타내기 위한 **기저**를 제공한다. 예를 들어, 직교좌표계에서 (x,y,z) 좌표는 기저 벡터 ex,ey,ez를 사용하여 표현된다.
- 기저 벡터가 바뀌면 같은 벡터라도 다른 **좌표계**에서 표현될 수 있다. 예를 들어, 물체가 월드 좌표계에서 표현되는 방식은 월드 좌표계의 기저 벡터에 의해 정의된다.

---

## **3. Unity에서의 기저와 좌표계**

Unity에서는 벡터와 좌표계를 다룰 때 **월드 좌표계**와 **로컬 좌표계**를 주로 사용한다. 각 좌표계는 서로 다른 **기준 벡터**를 가지며, 게임 엔진 내에서 벡터가 어떻게 변환되는지 이해하는 데 중요하다.

### **월드 좌표계 (World Coordinate System)**

- Unity의 **월드 좌표계**는 게임 세계의 고정된 좌표계로, **(0,0,0)** 원점을 기준으로 벡터가 정의된다.
- 게임 내 모든 객체는 **월드 좌표계**에서의 위치를 가지고 있으며, 월드 좌표계의 기저 벡터는 일반적으로 **x, y, z 축**이다.

### **로컬 좌표계 (Local Coordinate System)**

- Unity에서 **로컬 좌표계**는 객체의 **자신의 좌표계**를 의미한다. 각 객체는 자신의 **로컬 좌표계**에 대한 벡터를 가질 수 있으며, 이 좌표계는 객체의 위치, 회전, 스케일에 영향을 받는다.
- 로컬 좌표계의 기저 벡터는 객체의 **Transform** 컴포넌트에 의해 결정되며, 객체가 회전하면 로컬 좌표계의 기저 벡터도 함께 회전한다.

### **기저 벡터와 회전**

- Unity에서 객체가 회전할 때, **로컬 좌표계**의 기저 벡터가 회전하여 그 벡터들의 방향이 변경된다. 하지만 **월드 좌표계**는 고정되어 있으므로, 객체의 **로컬 좌표**와 **월드 좌표**는 서로 다른 기저 벡터를 갖는다.
- 예를 들어, 객체가 90도 회전하면 로컬 좌표계의 기저 벡터가 회전하지만, 월드 좌표계의 기저 벡터는 변하지 않는다.

---

## **4. Unity 예시**

### **1) 기저 벡터와 위치 계산**

```csharp

Vector3 position = new Vector3(5, 10, 15); // 월드 좌표계에서의 위치

```

위의 코드에서, 벡터 (5,10,15)는 **월드 좌표계**의 기저 벡터 ex,ey,ez 기준으로 정의된다.

### **2) 로컬 좌표계에서 벡터 계산**

```csharp
Transform objTransform = gameObject.transform;
Vector3 localPosition = objTransform.localPosition; // 객체의 로컬 좌표
```

이 코드에서는 **로컬 좌표계**를 사용하여 객체의 위치를 계산한다. 객체가 회전하더라도 **로컬 좌표**는 해당 객체의 좌표계 내에서 정의된다.

---

## **5. 기저와 좌표계의 변환**

기저 벡터가 변하면 좌표계도 달라지므로, **기저 벡터 변환**은 좌표계 변환을 의미한다. 예를 들어, 월드 좌표계에서 로컬 좌표계로 변환하려면 월드 좌표를 로컬 좌표로 **변환 행렬**을 통해 매핑해야 한다.

- **좌표 변환 행렬**을 사용하여 벡터의 좌표계를 변환할 수 있다. 예를 들어, Unity에서는 `Transform` 컴포넌트가 **월드 좌표계**와 **로컬 좌표계** 간의 변환을 관리한다.

# **법선 벡터 (Normal Vector)와 노름 (Norm)**

벡터와 관련된 중요한 개념 중 **법선 벡터**와 **노름**은 3D 공간에서 객체의 방향성, 크기 및 물리적 특성들을 정의하는 데 중요한 역할을 한다. Unity와 같은 게임 엔진에서도 충돌 처리, 표면의 방향 설정, 물리적 상호작용 등을 다룰 때 자주 사용된다.

---

## **1. 법선 벡터 (Normal Vector)**

**법선 벡터**는 특정 표면이나 곡선에 수직인 벡터를 의미한다. 주로 3D 그래픽스에서 표면의 **방향**을 정의하거나 **충돌** 및 **조명 계산**에서 사용된다.

### **법선 벡터의 특징**

- **수직성**: 법선 벡터는 표면의 **각 점**에서 수직인 방향을 가리킨다. 예를 들어, 평면의 법선 벡터는 그 평면에 수직으로 위치한다.
- **크기**: 법선 벡터의 크기는 그 자체로 중요하지 않지만, **단위 벡터**로 정규화하여 사용되는 경우가 많다. 단위 벡터로 표현하면, 벡터의 크기는 1로 고정된다.

### **법선 벡터의 계산**

- **2D 평면에서**: 두 벡터  $v1=(x1,y1)$ 와 $v2=(x2,y2)$ 가 있을 때, 두 벡터의 법선 벡터는 벡터의 교차 곱으로 구할 수 있다. 예를 들어, 2D 벡터의 법선은 (−y,x)로 계산된다.
- **3D 평면에서**: 두 벡터 v1와 v2가 주어졌을 때, 이들 벡터의 외적 (cross product)을 계산하여 법선 벡터를 구할 수 있다.
    
    $N=v1×v2$
    
    이 외적을 통해 나온 벡터 N는 두 벡터가 형성하는 평면에 수직인 법선 벡터가 된다.
    

### **Unity에서 법선 벡터 활용**

Unity에서는 벡터의 법선 벡터를 쉽게 계산할 수 있는 메소드들이 제공된다. 예를 들어, **충돌 처리** 시 표면의 법선 벡터는 `Collision.normal`을 통해 구할 수 있다.

```csharp
void OnCollisionEnter(Collision collision)
{
    Vector3 normal = collision.contacts[0].normal; // 법선 벡터 추출
    Debug.Log("충돌한 표면의 법선 벡터: " + normal);
}
```

법선 벡터는 충돌 지점에서 **표면의 방향**을 알 수 있게 해주며, 이를 통해 **반사 벡터**나 **빛의 반사 각도** 등을 계산할 수 있다.

---

## **2. 노름 (Norm)**

- 노름 (Norm)은 벡터의 **크기**를 나타내는 개념이다. 벡터의 크기는 그 벡터가 나타내는 물리적 양(예: 이동 거리, 힘의 크기 등)을 정의할 때 사용된다. 또한 노름은 벡터 공간에서 벡터의 **거리**를 계산하는 데 중요한 역할을 한다.

### **노름의 종류**

- **유클리드 노름 (Euclidean Norm)** 또는 **2-노름 (L2 norm)**: 가장 일반적인 노름으로, 벡터의 크기를 구할 때 사용된다. 2D 벡터 $v=(x,y)$의 유클리드 노름은 다음과 같이 계산된다.
    
    $||\mathbf{v}|| = \sqrt{x^2 + y^2}$
    
    3D 벡터에서는
    
    $||\mathbf{v}|| = \sqrt{x^2 + y^2 + z^2}$
    
- **1-노름 (L1 norm)**: 벡터의 각 성분들의 절댓값의 합이다.
    
    $||\mathbf{v}||_1 = |x| + |y| + |z|$
    
- **무한대 노름 (Infinity Norm)**: 벡터의 각 성분들 중에서 가장 큰 절댓값을 취한다.
    
    $||\mathbf{v}||_\infty = \max(|x|, |y|, |z|)$
    

### **노름의 의미와 활용**

- **벡터 크기**: 벡터의 **크기**는 해당 벡터가 나타내는 물리적 양을 의미한다. 예를 들어, Unity에서는 캐릭터나 물체의 **속도 벡터**의 크기를 계산하여 이동의 속도를 구할 수 있다.
- **벡터 간의 거리**: 두 벡터 v1와 v2 간의 거리는 두 벡터의 차이를 구하고, 그 차이 벡터의 노름을 계산하여 구할 수 있다.
$d(v1,v2)=∣∣v1−v2∣∣$

### **Unity에서 노름 계산**

Unity에서는 벡터의 크기를 구하는 **`Vector3.magnitude`** 속성을 제공하며, 이는 벡터의 유클리드 노름을 반환한다.

```csharp
Vector3 velocity = new Vector3(3, 4, 0);
float speed = velocity.magnitude; // 속도 계산
Debug.Log("속도 (크기): " + speed);
```

또한, 벡터의 **단위 벡터 (unit vector)**를 계산하려면 벡터를 그 벡터의 크기(norm)로 나누면 된다. 이를 통해 벡터는 크기 1의 벡터로 정규화된다.

```csharp
Vector3 normalizedVelocity = velocity.normalized; // 정규화된 속도
```

---

## **3. Unity에서의 법선 벡터와 노름의 활용**

- **법선 벡터**는 물체의 충돌 처리, 물리적 반응, 표면의 특성 등을 다룰 때 중요한 역할을 한다. 예를 들어, **조명 계산**에서 법선 벡터는 표면의 밝기를 결정하는 데 사용된다.
- **노름**은 벡터의 크기를 계산하거나, 물체 간의 거리를 계산할 때 사용된다. 예를 들어, 플레이어와 적 캐릭터 간의 거리를 계산할 때 `Vector3.Distance` 함수를 사용할 수 있다.

# **내적 (Dot Product)**

내적은 두 벡터 간의 **관계**를 수학적으로 표현하는 연산으로, 두 벡터가 얼마나 **비슷한 방향**을 가리키는지, 즉 **각도**를 측정하는 데 사용된다. 내적은 3D 공간에서 벡터의 **투영**을 계산하거나, 물리적 상호작용을 모델링할 때 중요한 역할을 한다.

---

## **1. 내적의 정의**

두 벡터 $A=(Ax,Ay,Az)$와 $B=(Bx,By,Bz)$가 있을 때, 이 두 벡터의 내적은 다음과 같이 계산된다:

$A⋅B=AxBx+AyBy+AzBz$

내적의 결과는 **스칼라 값**이며, 벡터의 크기나 방향이 아닌 크기만을 나타낸다.

또한 내적은 다음과 같은 **기하학적 해석**을 가지고 있다:

$A⋅B=∣∣A∣∣∣∣B∣∣cos(θ)$

여기서:

- $∣∣A∣∣$와 $∣∣B∣∣$는 각각 벡터 A와 B의 크기(노름),
- θ는 두 벡터 간의 각도이다.

즉, 내적은 두 벡터의 **크기**와 **각도**에 따라 결정된다. 두 벡터가 **같은 방향**일수록 내적은 커지고, **수직**일 경우 내적은 0이 된다.

---

## **2. 내적의 성질**

- **교환 법칙**: 내적은 교환 법칙이 성립한다.
    
    $A⋅B=B⋅A$
    
- **분배 법칙**: 내적은 분배 법칙을 따른다.
    
    $A⋅(B+C)=A⋅B+A⋅C$
    
- **스칼라 곱**: 벡터와 스칼라를 곱한 후 내적을 계산해도 결과는 같다.(c⋅A)⋅B=c⋅(A⋅B)
    
    $(c⋅A)⋅B=c⋅(A⋅B)$
    

---

## **3. 내적의 활용**

내적은 여러 가지 중요한 물리적 및 기하학적 계산에서 사용된다. Unity에서도 내적을 활용하여 벡터 간의 관계를 파악할 수 있다.

### **(1) 두 벡터의 각도 계산**

내적을 사용하여 두 벡터가 이루는 각도를 계산할 수 있다. 두 벡터 A\mathbf{A}A와 B\mathbf{B}B의 내적을 이용하면, 다음과 같이 각도 θ\thetaθ를 구할 수 있다.

$\cos(\theta) = \frac{\mathbf{A} \cdot \mathbf{B}}{||\mathbf{A}|| \, ||\mathbf{B}||}$

따라서 θ\thetaθ는 다음과 같이 구할 수 있다.

$\theta = \cos^{-1} \left( \frac{\mathbf{A} \cdot \mathbf{B}}{||\mathbf{A}|| \, ||\mathbf{B}||} \right)$

### **(2) 벡터의 투영**

벡터 A를 벡터 B위로 **투영**할 때 내적을 사용한다. 벡터 A를 B 방향으로 투영한 벡터는 다음과 같이 계산된다.

$\text{proj}_{\mathbf{B}}(\mathbf{A}) = \frac{\mathbf{A} \cdot \mathbf{B}}{||\mathbf{B}||^2} \mathbf{B}$

이렇게 하면 벡터 A의 B 방향에 대한 투영 벡터를 구할 수 있다.

### **(3) 두 벡터의 방향성 비교**

두 벡터의 내적이 양수라면 두 벡터는 **같은 방향**을 가리키고, 내적이 0이라면 두 벡터는 **수직**이다. 내적이 음수라면 두 벡터는 **반대 방향**을 가리킨다.

### **(4) 물리학적 적용**

- **일 (Work)**: 물리학에서, 벡터 F와 이동 벡터 d의 내적은 **일**을 구할 때 사용된다.
    
    $W=F⋅d$
    
    이 식은 물체가 힘을 받아서 이동할 때, 힘이 하는 일을 계산하는 데 사용된다.
    
- **조명 계산**: 컴퓨터 그래픽스에서, 내적은 표면의 법선 벡터와 광원 벡터 간의 각도를 계산하는 데 사용되어, 표면의 밝기를 결정하는 **조명 모델**에서 중요한 역할을 한다.

---

## **4. Unity에서의 내적 사용**

Unity에서는 `Vector3.Dot` 메서드를 사용하여 벡터의 내적을 계산할 수 있다. 이 함수는 두 벡터의 내적을 계산하여 반환한다.

```csharp
Vector3 A = new Vector3(1, 0, 0);
Vector3 B = new Vector3(0, 1, 0);

float dotProduct = Vector3.Dot(A, B); // A와 B의 내적 계산
Debug.Log("내적 값: " + dotProduct); // 결과는 0, 두 벡터가 수직이므로
```

내적을 이용하여 두 벡터 간의 각도나 투영 등을 쉽게 계산할 수 있으며, 게임에서 물리적 상호작용, 조명 처리 및 충돌 감지에 널리 사용된다.

---

## **5. 내적의 예시**

1. **두 벡터의 각도 계산**: 두 벡터가 이루는 각도를 계산하여, **조명**이나 **카메라 시점**의 방향을 결정할 수 있다.
2. **조명 모델**: 표면의 법선 벡터와 광원 벡터의 내적을 이용하여 조명 효과를 계산한다.
3. **투영**: 벡터가 다른 벡터를 기준으로 얼마나 비슷한 방향으로 향하는지 계산할 때 유용하다.
4. **충돌 감지**: 물체가 특정 방향으로 이동하는지, 다른 물체와 충돌하는지 확인할 때 사용된다
